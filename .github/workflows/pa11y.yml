name: A11y (Pa11y + Lighthouse)

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Run mode: urls (comma-separated) or sitemap"
        type: choice
        required: true
        default: urls
        options:
          - urls
          - sitemap
      urls:
        description: "URLs (comma separated). Used when mode=urls"
        type: string
        required: false
      sitemap_url:
        description: "Sitemap URL (https://.../sitemap.xml). Used when mode=sitemap"
        type: string
        required: false

jobs:
  a11y:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      # -------------------------
      # Pa11y
      # -------------------------
      - name: Run Pa11y CI
        continue-on-error: true
        env:
          PA11Y_URLS: ${{ inputs.urls }}
        run: |
          set -euo pipefail
          mkdir -p reports/pa11y/html

          if [ "${{ inputs.mode }}" = "sitemap" ]; then
            if [ -z "${{ inputs.sitemap_url }}" ]; then
              echo "mode=sitemap requires inputs.sitemap_url"
              exit 1
            fi

            # IMPORTANT: actually execute the command
            npx pa11y-ci --config .pa11yci.js --sitemap "${{ inputs.sitemap_url }}"
          else
            if [ -z "${{ inputs.urls }}" ]; then
              echo "mode=urls requires inputs.urls (comma or newline separated)"
              exit 1
            fi

            npx pa11y-ci --config .pa11yci.js
          fi

      - name: Upload pa11y reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pa11y-reports
          path: reports/pa11y

      # -------------------------
      # Resolve URL list ONCE for Lighthouse (works for single URL too)
      # -------------------------
      - name: Resolve Lighthouse URLs (JS)
        id: lhci_urls
        if: always()
        env:
          MODE: ${{ inputs.mode }}
          INPUT_URLS: ${{ inputs.urls }}
          SITEMAP_URL: ${{ inputs.sitemap_url }}
          MAX_URLS: "20"
        run: |
          set -euo pipefail

          node <<'NODE'
          const fs = require("fs");
          const http = require("http");
          const https = require("https");
          const zlib = require("zlib");

          const mode = process.env.MODE || "urls";
          const inputUrls = process.env.INPUT_URLS || "";
          const sitemapUrl = process.env.SITEMAP_URL || "";
          const maxUrls = Number(process.env.MAX_URLS || 20);
          const outFile = process.env.GITHUB_OUTPUT;

          function splitUrls(str) {
            return (str || "")
              .split(/[\r\n,]+/)
              .map(s => s.trim())
              .filter(Boolean);
          }

          function fetch(url) {
            return new Promise((resolve, reject) => {
              const lib = url.startsWith("https:") ? https : http;

              const req = lib.get(url, {
                headers: { "User-Agent": "Mozilla/5.0", "Accept-Encoding": "gzip" }
              }, (res) => {
                const chunks = [];
                res.on("data", c => chunks.push(c));
                res.on("end", () => {
                  const buf = Buffer.concat(chunks);
                  const isGzip =
                    (res.headers["content-encoding"] || "").includes("gzip") ||
                    url.toLowerCase().endsWith(".gz");

                  if (isGzip) {
                    zlib.gunzip(buf, (err, out) => err ? reject(err) : resolve(out.toString("utf8")));
                  } else {
                    resolve(buf.toString("utf8"));
                  }
                });
              });

              req.on("error", reject);
            });
          }

          function extractLocs(xml) {
            return [...xml.matchAll(/<loc>\s*([^<]+)\s*<\/loc>/g)].map(m => m[1].trim());
          }

          async function urlsFromSitemap(url, seen = new Set(), collected = []) {
            if (seen.has(url)) return collected;
            seen.add(url);

            const xml = await fetch(url);
            const lower = xml.toLowerCase();

            if (lower.includes("<sitemapindex")) {
              const sitemaps = extractLocs(xml).filter(u => u.startsWith("http"));
              for (const sm of sitemaps) {
                if (collected.length >= maxUrls) break;
                try { await urlsFromSitemap(sm, seen, collected); } catch (_) {}
              }
              return collected;
            }

            // urlset or unknown: treat locs as page URLs, filter out .xml
            const urls = extractLocs(xml)
              .filter(u => u.startsWith("http"))
              .filter(u => !u.toLowerCase().endsWith(".xml"));

            for (const u of urls) {
              if (collected.length >= maxUrls) break;
              collected.push(u);
            }
            return collected;
          }

          (async () => {
            let urls = [];

            if (mode === "urls") {
              urls = splitUrls(inputUrls);
              if (!urls.length) throw new Error("mode=urls requires inputs.urls (comma or newline separated)");
            } else {
              if (!sitemapUrl) throw new Error("mode=sitemap requires inputs.sitemap_url");
              urls = await urlsFromSitemap(sitemapUrl);
            }

            urls = urls.filter(u => u.startsWith("http")).slice(0, maxUrls);

            if (!urls.length) throw new Error("No URLs resolved for Lighthouse.");

            // Persist as a multi-line step output
            fs.appendFileSync(outFile, `lhci_urls<<EOF\n${urls.join("\n")}\nEOF\n`, "utf8");

            console.log(`Resolved ${urls.length} Lighthouse URL(s). Sample:`);
            console.log(urls.slice(0, 3).join("\n"));
          })().catch(err => {
            console.error(err);
            process.exit(1);
          });
          NODE

      # -------------------------
      # Lighthouse CI
      # -------------------------
      - name: Run Lighthouse CI
        if: always()
        continue-on-error: true
        env:
          LHCI_URLS: ${{ steps.lhci_urls.outputs.lhci_urls }}
          LHCI_RUNS: "1"
        run: |
          set -euo pipefail

          if [ -z "${LHCI_URLS:-}" ]; then
            echo "LHCI_URLS is empty; cannot run Lighthouse."
            exit 1
          fi

          mkdir -p reports/lighthouse

          echo "LHCI_URLS first 3:"
          echo "$LHCI_URLS" | head -n 3

          # Use your repo config file (recommended)
          npx lhci autorun --config=./.lighthouserc.js

      - name: Upload lighthouse reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lighthouse-reports
          path: reports/lighthouse
